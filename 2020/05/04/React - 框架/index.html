<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.png">
  <link rel="icon" type="image/png" href="/img/logo.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>React - 框架 - 浪里淘沙的小法师</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>浪里淘沙的小法师</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-05-04 21:00">
      2020年5月4日 晚上
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      2.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      33
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <p>React 的相关知识，内容包括简介、创建一个 React 项目、React 组件、props、state、事件绑定、Class 组件、函数组件。</p>
<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>React 是一个用于创建用户界面的开源 JavaScript 框架<br>_<br><em>中文官网：React.js → <em>[</em>点击这里_](<a href="https://zh-hans.reactjs.org/" target="_blank" rel="noopener">https://zh-hans.reactjs.org/</a>)</em> _</p>
<h3 id="1-简单类比"><a href="#1-简单类比" class="headerlink" title="1. 简单类比"></a>1. 简单类比</h3><blockquote>
<p>Webpack 就像一个没有装修过的“毛坯房”，提供了一个基本的“房子”，满足遮风挡雨的需求，不能直接满足睡觉、写字等需求。</p>
</blockquote>
<blockquote>
<ul>
<li>想睡觉，自己添加床</li>
<li>想写字，自己添加桌子<br>_&gt; Vue 就像“中国风”的精装修，床、桌子等已经都帮我们搞定，不用自己添加。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>如果需求不满足，也可以自己在上面增增减减做改动</li>
<li>因为 Vue 就是基于 Webpack 开发的</li>
</ul>
</blockquote>
<p>如果把 Webpack 比喻成一个没有装修过的“毛坯房”，把 Vue 比喻成“中国风”的精装修，那么 React 就是“欧美风”的精装修，基本需求帮我们搞定，自己可以在上面增增减减做改动。</p>
<h2 id="二、创建一个-React-项目"><a href="#二、创建一个-React-项目" class="headerlink" title="二、创建一个 React 项目"></a>二、创建一个 React 项目</h2><h3 id="1-CDN-引入-React"><a href="#1-CDN-引入-React" class="headerlink" title="1. CDN 引入 React"></a>1. CDN 引入 React</h3><ul>
<li>script 标签引入 「React」和「React DOM」</li>
</ul>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.bootcss.com/react/16.10.2/umd/react.development.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.bootcss.com/react-dom/16.10.2/umd/react-dom.development.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>


<h3 id="2-React-CLI-创建项目"><a href="#2-React-CLI-创建项目" class="headerlink" title="2. React CLI 创建项目"></a>2. React CLI 创建项目</h3><ul>
<li>我们可以直接在 JS 里使用 JSX 语法</li>
<li>因为 babel-loader 内置了 jsx-loader</li>
</ul>
<pre><code class="hljs dsconfig"><span class="hljs-string">yarn </span><span class="hljs-string">global </span><span class="hljs-string">add </span><span class="hljs-built_in">create-react-app</span>
<span class="hljs-built_in">create-react-app</span> <span class="hljs-string">react-demo-</span>1

<span class="hljs-string">cd </span><span class="hljs-string">react-demo-</span>1
<span class="hljs-string">yarn </span><span class="hljs-string">start</span></code></pre>


<h2 id="三、React-组件"><a href="#三、React-组件" class="headerlink" title="三、React 组件"></a>三、React 组件</h2><h3 id="1-基本公式"><a href="#1-基本公式" class="headerlink" title="1. 基本公式"></a>1. 基本公式</h3><p>React 的风格是“在 JS 里写标签”，它的基本公式如下，创建一个虚拟 DOM</p>
<ul>
<li>React.createElement(‘div’, ClassName=”greet”,Hello)</li>
</ul>
<ol>
<li>参数一接受字符串 / 类 / 函数</li>
<li>参数二写属性的 key 和 Value</li>
<li>参数三写文本内容</li>
</ol>
<p>React 的 babal-loader 能够让我们写 HTML 风格，然后转译成虚拟 DOM 形式</p>
<p>该网站可以让我们看到转译前后对比，帮助理解：<a href="https://babeljs.io/repl#?browsers=&build=&builtIns=false&spec=false&loose=false&code_lz=Q&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=es2015%2Creact%2Cstage-2&prettier=false&targets=&version=7.9.6&externalPlugins=" target="_blank" rel="noopener"><em>babel online</em></a></p>
<pre><code class="hljs routeros">&lt;div <span class="hljs-attribute">className</span>=<span class="hljs-string">"red"</span> <span class="hljs-attribute">title</span>=<span class="hljs-string">"name"</span>&gt;Hello&lt;/div&gt;

React.createElement(<span class="hljs-string">"div"</span>, &#123;
  className: <span class="hljs-string">"red"</span>,
  title: <span class="hljs-string">"name"</span>
&#125;, <span class="hljs-string">"Hello"</span>);</code></pre>


<ul>
<li>参数一传入字符串，得到元素</li>
<li>参数一传入类，React 会构造出一个实例，调用 render 方法，获取其返回值</li>
<li>参数一传入函数，React 会调用这个函数，获取其返回值</li>
</ul>
<h3 id="2-使用组件"><a href="#2-使用组件" class="headerlink" title="2. 使用组件"></a>2. 使用组件</h3><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>)</span>&#123;
	<span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"App"</span>&gt;</span></span>
<span class="xml">  	<span class="hljs-tag">&lt;<span class="hljs-name">Test</span> /&gt;</span></span>
<span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)
&#125;
ReactDom.render(App(),querySelector(<span class="hljs-string">'#root'</span>))</code></pre>


<h3 id="3-类组件"><a href="#3-类组件" class="headerlink" title="3. 类组件"></a>3. 类组件</h3><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;
	constructor()&#123;
  	<span class="hljs-keyword">super</span>()
    <span class="hljs-keyword">this</span>.state = &#123;n:<span class="hljs-number">100</span>&#125;
  &#125;
  add()&#123;
  	<span class="hljs-keyword">this</span>.setState(&#123;n:<span class="hljs-keyword">this</span>.state.n+<span class="hljs-number">1</span>&#125;)
  &#125;
	render()&#123;
		<span class="hljs-keyword">return</span> (&lt;div className=<span class="hljs-string">"test"</span>&gt;
    n:&#123;<span class="hljs-keyword">this</span>.state.n&#125;
    &lt;button onClick=&#123;()=&gt;<span class="hljs-keyword">this</span>.add()&#125;&gt;+<span class="hljs-number">1</span>&lt;/button&gt;
    &lt;/div&gt;)
  &#125;
&#125;</code></pre>


<h3 id="4-函数组件"><a href="#4-函数组件" class="headerlink" title="4. 函数组件"></a>4. 函数组件</h3><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> Test2 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;
  <span class="hljs-keyword">let</span> [n, setN] = React.useState(<span class="hljs-number">100</span>)
  <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"test2"</span>&gt;</span></span>
<span class="xml">		n:&#123;n&#125;</span>
<span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setN(n + 1)&#125;&gt;+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
<span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)
&#125;</code></pre>


<h3 id="5-组件的特点"><a href="#5-组件的特点" class="headerlink" title="5. 组件的特点"></a>5. 组件的特点</h3><p><strong>类组件中</strong></p>
<ul>
<li>直接修改 state.n 不会更新到 UI，需要使用 setState() 异步更新 UI</li>
<li>setState(this.state) 不被推荐，React 希望我们不要修改旧的 state，不可变数据</li>
<li>这是函数式理念</li>
</ul>
<p><strong>函数组件中</strong></p>
<ul>
<li>通过 setX 改变数据，它永远不改变旧 state，它产生新 state</li>
<li>没有 this，一律使用参数和变量</li>
</ul>
<h2 id="四、props"><a href="#四、props" class="headerlink" title="四、props"></a>四、props</h2><ul>
<li>类比 Vue 中的 props</li>
</ul>
<p>React 中，你可以传字符串，也可以传表达式</p>
<ul>
<li>传字符串，用 “” 括起来</li>
<li>传表达式，用 {} 括起来</li>
</ul>
<h3 id="1-类组件-props"><a href="#1-类组件-props" class="headerlink" title="1. 类组件 props"></a>1. 类组件 props</h3><ul>
<li>通过 this.props.message 可以拿到父元素传的参数</li>
</ul>
<pre><code class="hljs axapta"><span class="hljs-comment">// 父元素传参给 Test</span>
&lt;Test message=<span class="hljs-string">"Hello"</span> /&gt;

<span class="hljs-comment">// 子元素直接使用参数</span>
&lt;<span class="hljs-keyword">div</span>&gt;父元素给我传的参数是：&#123;<span class="hljs-keyword">this</span>.props.message&#125;&lt;/<span class="hljs-keyword">div</span>&gt;</code></pre>


<h3 id="2-函数组件-props"><a href="#2-函数组件-props" class="headerlink" title="2. 函数组件 props"></a>2. 函数组件 props</h3><ul>
<li>通过 props.messge2 可以拿到父元素传的参数</li>
</ul>
<pre><code class="hljs javascript"><span class="hljs-comment">// 父元素传参给 Test2</span>
<span class="hljs-keyword">let</span> age = <span class="hljs-number">20</span>
&lt;Test2 message2=&#123;<span class="hljs-string">`你今年<span class="hljs-subst">$&#123;<span class="hljs-number">20</span>&#125;</span>岁了`</span>&#125;&gt;

<span class="hljs-comment">// 子元素通过函数接收参数并使用</span>
<span class="hljs-keyword">let</span> Test2 = (props)&#123;
	<span class="hljs-keyword">return</span> (
  	&lt;div&gt;父元素传给我的参数是：&#123;props.message2&#125;&lt;<span class="hljs-regexp">/div&gt;</span>
<span class="hljs-regexp">  )</span>
<span class="hljs-regexp">&#125;</span></code></pre>


<h2 id="五、state"><a href="#五、state" class="headerlink" title="五、state"></a>五、state</h2><ul>
<li>类比 Vue 中的 data</li>
</ul>
<h3 id="1-类组件-state"><a href="#1-类组件-state" class="headerlink" title="1. 类组件 state"></a>1. 类组件 state</h3><ul>
<li>初始化数据，this.state = {n: 100}</li>
<li>读数据，{this.state.n}</li>
<li>改数据，add(){ this.setState( { n: this.state.n + 1 } ) }<ul>
<li>不能直接 this.setState.n +=1</li>
<li>因为 React 不会一直监听数据对象的变化</li>
</ul>
</li>
</ul>
<p>React 希望改变数据之后，传一个新的数据对象，它不推荐「在原有 state 修改，再传这个 state」</p>
<ul>
<li>React 理念是：数据是不可变的</li>
</ul>
<p>setState 是一个异步的更新 UI 过程，为了不混淆旧 state 和新 state，更加推荐在 setState 里面传函数</p>
<pre><code class="hljs pf">add = ()=&gt;&#123;
	<span class="hljs-built_in">set</span>State((<span class="hljs-keyword">state</span>)=&gt;(&#123;x: <span class="hljs-keyword">state</span>.x + <span class="hljs-number">1</span>&#125;))
&#125;</code></pre>


<h3 id="2-函数组件-state"><a href="#2-函数组件-state" class="headerlink" title="2. 函数组件 state"></a>2. 函数组件 state</h3><ul>
<li>使用 useState 返回数组</li>
<li>第一项用于读数据</li>
<li>第二项用于写数据</li>
</ul>
<pre><code class="hljs jboss-cli">let [n,<span class="hljs-keyword">set</span>N] = useState<span class="hljs-params">(100)</span>
<span class="hljs-string">//</span> n 用于读，<span class="hljs-keyword">set</span>N 用于写</code></pre>


<ul>
<li>setN 永远不会改变 n，它会产生一个新的 n</li>
<li>这和 this.setState 不同，this.setState 会等一会改变 n</li>
</ul>
<h3 id="3-复杂-state"><a href="#3-复杂-state" class="headerlink" title="3. 复杂 state"></a>3. 复杂 state</h3><p>类组件中，对 state 的部分数据修改，其他数据它会自动沿用上次的值</p>
<ul>
<li>类组件 setState 会自动合并第一层属性，不会合并第二层属性</li>
<li>熟练运用 …</li>
</ul>
<pre><code class="hljs pf">...this.<span class="hljs-keyword">state</span>
Object.assign()</code></pre>


<p>函数组件中，对 state 部分修改，其他数据不会沿用上次的值</p>
<ul>
<li>函数组件 setState 不会自动合并</li>
<li>熟练运用 …</li>
</ul>
<pre><code class="hljs pf">// 推荐使用如下方式
let [m,<span class="hljs-built_in">set</span>M] = useState(<span class="hljs-number">100</span>)
let [n,<span class="hljs-built_in">set</span>N] = useState(<span class="hljs-number">100</span>)

// 如果想使用 <span class="hljs-keyword">state</span> 对象的形式，自己主动复制一份
let [<span class="hljs-keyword">state</span>,<span class="hljs-built_in">set</span>State] = useState(&#123;m:<span class="hljs-number">100</span>,n:<span class="hljs-number">100</span>&#125;)

...<span class="hljs-keyword">state</span></code></pre>


<h2 id="六、事件绑定"><a href="#六、事件绑定" class="headerlink" title="六、事件绑定"></a>六、事件绑定</h2><h3 id="1-类组件的事件绑定"><a href="#1-类组件的事件绑定" class="headerlink" title="1. 类组件的事件绑定"></a>1. 类组件的事件绑定</h3><ul>
<li>()=&gt;fn() 的写法是最安全的，当外部调用该函数传入 this 时，函数 fn 如果里面使用 this，则不会改变其 this 的指向</li>
</ul>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span>=&gt;</span>fn()&#125;&gt;+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre>


<h3 id="2-事件绑定终极写法"><a href="#2-事件绑定终极写法" class="headerlink" title="2. 事件绑定终极写法"></a>2. 事件绑定终极写法</h3><ul>
<li>fn 写成箭头函数，取消中间转换的过程</li>
<li>以下写法中，add 函数 写在 constructor 外面，也能添加到实例上</li>
</ul>
<pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;
	constructor()&#123;
  	<span class="hljs-keyword">super</span>()
  &#125;
	add = ()=&gt;&#123;<span class="hljs-keyword">this</span>.setState(&#123;n: <span class="hljs-keyword">this</span>.state.n + <span class="hljs-number">1</span>&#125;)&#125;
&#125;

&lt;button onClick=&#123;add&#125;&gt;+<span class="hljs-number">1</span>&lt;/button&gt;</code></pre>


<h2 id="七、Class-组件"><a href="#七、Class-组件" class="headerlink" title="七、Class 组件"></a>七、Class 组件</h2><h3 id="1-创建-Class-组件"><a href="#1-创建-Class-组件" class="headerlink" title="1. 创建 Class 组件"></a>1. 创建 Class 组件</h3><ul>
<li>使用 ES6 方式创建组件更好</li>
</ul>
<p><strong>ES5 方式（已过时）</strong></p>
<pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>

<span class="hljs-keyword">const</span> App = React.createComponent(
	render()&#123;
  	<span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)
  &#125;
)</code></pre>


<p><strong>ES6 方式</strong></p>
<pre><code class="hljs scala"><span class="hljs-keyword">import</span> <span class="hljs-type">React</span> from <span class="hljs-symbol">'reac</span>t'

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;
	constructor(props)&#123;
  	<span class="hljs-keyword">super</span>(props)
  &#125;
  render()&#123;
  	<span class="hljs-keyword">return</span> (&lt;div&gt;<span class="hljs-type">Hello</span>&lt;/div&gt;)
  &#125;
&#125;</code></pre>


<h3 id="2-props"><a href="#2-props" class="headerlink" title="2. props"></a>2. props</h3><ul>
<li>传 props：父组件中，<App2 data={this.state.n} func={this.func}>Hello</App><ul>
<li>父组件传数据时，props 被包装成一个对象，{n:100, func:…, children: Hello}</li>
<li>func 是一个回调</li>
</ul>
</li>
<li>读 props：子组件中，this.xxx</li>
<li>写 props，不要修改 props 的值<ul>
<li>这是一个理念，既然是外部传进来的数据，那就由外部修改</li>
</ul>
</li>
</ul>
<pre><code class="hljs scala"><span class="hljs-comment">// 父组件</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;
	constructor()&#123;
  	<span class="hljs-keyword">super</span>()
    <span class="hljs-keyword">this</span>.state=&#123;n:<span class="hljs-number">100</span>&#125;
  &#125;
  func=()=&gt;&#123;&#125;
  render()&#123;
  	<span class="hljs-keyword">return</span> (
    	&lt;<span class="hljs-type">App2</span> data=&#123;<span class="hljs-keyword">this</span>.state.n&#125; func=&#123;<span class="hljs-keyword">this</span>.func&#125;&gt;<span class="hljs-type">Hello</span>&lt;/<span class="hljs-type">App</span>&gt;
    )
  &#125;
&#125;

<span class="hljs-comment">// 子组件</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;
	constructor(props)&#123;
  	<span class="hljs-keyword">super</span>(props)
    render()&#123;
    	<span class="hljs-keyword">return</span> (
      &lt;div onClick=&#123;<span class="hljs-keyword">this</span>.props.func&#125;&gt;  <span class="hljs-comment">// func 函数</span>
      &lt;div&gt;&#123;<span class="hljs-keyword">this</span>.props.n&#125;&lt;/div&gt;  <span class="hljs-comment">// 100</span>
      &lt;div&gt;&#123;<span class="hljs-keyword">this</span>.props.children&#125;&lt;/div&gt;  <span class="hljs-comment">// Hello</span>
      &lt;/div&gt;
      )
    &#125;
  &#125;
&#125;</code></pre>


<p>componentWillReceiveProps（已经弃用）</p>
<p>这是一个生命周期钩子，在 props 变化时触发，现已更名为 UNSAFE_componentWillReceiveProps</p>
<pre><code class="hljs haxe">componentWillReceiveProps(<span class="hljs-keyword">new</span><span class="hljs-type">Props</span>,<span class="hljs-keyword">new</span><span class="hljs-type">Context</span>)&#123;
	console.log(<span class="hljs-built_in">this</span>.props)  <span class="hljs-comment">// 旧的 props</span>
  console.log(<span class="hljs-keyword">new</span><span class="hljs-type">Props</span>)  <span class="hljs-comment">// 新的 props</span>
&#125;</code></pre>


<h3 id="3-state"><a href="#3-state" class="headerlink" title="3. state"></a>3. state</h3><ul>
<li>创建 state：在 constructor 函数中，this.state = xxx</li>
<li>读 state：this.state</li>
<li>写 state：this.setState({n:100})<ul>
<li>它是异步更新 UI 的</li>
<li>this.setState(state=&gt;({n: state.n+1}))，这种写法能够更方便理解 state 的值</li>
<li>setState 函数还可以接收一个函数参数 fn，在写 state 成功后运行</li>
<li>写 state 会 shallow merge，会自动将新、旧 state 进行一级合并</li>
<li>不推荐直接在旧 state 直接修改值，虽然这是可行的</li>
</ul>
</li>
</ul>
<p>使用 React.PureComponent 会在 render 之前把新 props、state 和旧 props、state 做比较，只比较第一层，如果有变化，则会 render</p>
<h3 id="4-constructor"><a href="#4-constructor" class="headerlink" title="4. constructor"></a>4. constructor</h3><ul>
<li>初始化 props 和 state</li>
</ul>
<h3 id="5-shouldComponentUpdate"><a href="#5-shouldComponentUpdate" class="headerlink" title="5. shouldComponentUpdate"></a>5. shouldComponentUpdate</h3><ul>
<li>返回 true，UI 更新</li>
<li>返回 false，阻止 UI 更新</li>
</ul>
<p>它允许我们手动判断是否要进行组件更新，我们可以根据应用场景灵活设置返回值，以避免不必要的更新</p>
<p>React 有一个功能自动判断 UI 更新，名字叫 React.PureComponent，可以代替 React.Component</p>
<ul>
<li>同样，它只判断第一层</li>
</ul>
<h3 id="6-render"><a href="#6-render" class="headerlink" title="6. render"></a>6. render</h3><ul>
<li>展示视图 return (<div>…<div>)，只能有一个根元素</li>
<li>如果有两个根元素，则外部再套一个 React.Fragment 标签，可简写成 &lt;&gt;&lt;/&gt;</li>
</ul>
<p>render 可以写 if…else，?: 表达式，不能直接写 for 循环，需要用数组，可以写 array.map（循环）</p>
<h3 id="7-componentDidMount"><a href="#7-componentDidMount" class="headerlink" title="7. componentDidMount"></a>7. componentDidMount</h3><ul>
<li>在元素插入页面后执行代码，这些代码依赖 DOM</li>
<li>此处可以写发起加载数据的 AJAX 请求</li>
<li>首次渲染会执行此钩子</li>
</ul>
<h3 id="8-componentDidUpdate"><a href="#8-componentDidUpdate" class="headerlink" title="8. componentDidUpdate"></a>8. componentDidUpdate</h3><ul>
<li>在视图更新后执行代码</li>
<li>此处也可以发起 AJAX 请求，用于更新数据</li>
<li>首次渲染不会执行此钩子</li>
</ul>
<h3 id="9-componentWillUnmount"><a href="#9-componentWillUnmount" class="headerlink" title="9. componentWillUnmount"></a>9. componentWillUnmount</h3><ul>
<li>组件将要被移除页面然后被销毁时执行代码</li>
<li>unmount 过的组件不会再次 mount</li>
</ul>
<h2 id="八、函数组件"><a href="#八、函数组件" class="headerlink" title="八、函数组件"></a>八、函数组件</h2><ul>
<li>函数组件能完全代替 Class 组件</li>
<li>useState 解决 state</li>
<li>useEffect 解决 lifecycle</li>
<li>它还有一些 Hooks</li>
<li>它可以自定义钩子满足需求</li>
</ul>
<h3 id="1-创建函数组件"><a href="#1-创建函数组件" class="headerlink" title="1. 创建函数组件"></a>1. 创建函数组件</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 常用方式</span>
<span class="hljs-keyword">const</span> App = <span class="hljs-function">(<span class="hljs-params">props</span>)=&gt;</span>&#123;
	<span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>props.message<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&#125;

<span class="hljs-comment">// 省略 () 和 return</span>
<span class="hljs-keyword">const</span> App2 = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>props.message<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>

<span class="hljs-comment">// 使用普通函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App3</span>(<span class="hljs-params">props</span>)</span>&#123;
	<span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>props.message<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&#125;</code></pre>


<h3 id="2-useEffect"><a href="#2-useEffect" class="headerlink" title="2. useEffect"></a>2. useEffect</h3><p><strong>模拟 componentDidMount</strong></p>
<ul>
<li>第二个参数是空数组</li>
</ul>
<pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">useEffect</span><span class="hljs-params">(()</span></span>=&#123;console.log(<span class="hljs-string">'第一次渲染'</span>)&#125;,[])</code></pre>


<p><strong>模拟 componentDidUpdate</strong></p>
<ul>
<li>任意数据变化时触发，第二个参数省略</li>
<li>部分数据变化时触发，第二个参数写成包含数据的数组</li>
</ul>
<pre><code class="hljs coffeescript">useEffect(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'任意数据变了'</span>)&#125;)
useEffect(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'n 或 m 变化了'</span>)&#125;,[m,n])</code></pre>


<p>该用法在数据第一次渲染时也会触发，如果不想第一次触发，可以自己写一个 useUpdate 钩子满足需求</p>
<p><strong>模拟 componentWillUnmount</strong></p>
<ul>
<li>函数里面套一个函数</li>
</ul>
<pre><code class="hljs javascript">useEffect(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;
	<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'第一次渲染'</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;
  	<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'组件要消亡了'</span>)
  &#125;
&#125;)</code></pre>


<p><em>「@浪里淘沙的小法师」</em></p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/05/04/Vue%20-%20%E6%A1%86%E6%9E%B6/">
                        <span class="hidden-mobile">Vue - 框架</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "React - 框架&nbsp;",
      ],
      cursorChar: "",
      typeSpeed: 80,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
